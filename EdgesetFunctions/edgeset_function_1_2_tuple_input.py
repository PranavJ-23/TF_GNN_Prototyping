# -*- coding: utf-8 -*-
"""Edgeset_function_1_2_tuple_input

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hG73I-GMxo9R73Pw8H_bLH3H_isJNTga
"""

import numpy as np
import pandas as pd

"""
Example input:

n_nodes_list  = [10, 10, 10]
n_conn_list   = [[1,2], [1,3], [1,1]]
n_edges_list  = [(2, 7), (6, 8), (3,4)]
bidirectional = True

df_list, edge_df = generate_graph_random_edges(n_nodes_list,  n_conn_list, n_edges_list, bidirectional)

The number of nodes between each edgeset can now be randomised between a range.
This is done by entering the range for thr number of edges for the corresponding nodeset connections in "n_edges_list". Follows the same order as before,
n_edges_list[0] is the range of edges for connection n_conn_list[0].

"""

def generate_graph_random_edges(n_nodes_list, n_conn_list, n_edges_list, bidirectional):

    nodes_list   = [np.arange(n_nodes) for n_nodes in n_nodes_list]
    node_sets    = len(n_nodes_list)

    df_list = []
    edge_set = pd.DataFrame()

    edge_sets_ij = []


    for ij in range(len(n_nodes_list)):
      low  = n_edges_list[ij][0]
      high = n_edges_list[ij][1]
      n_edges = np.random.randint(low=low, high=high)
      source_ij = n_conn_list[ij][0]
      targets   = n_conn_list[ij][1]
      connected_nodes_2 = np.random.choice(nodes_list[targets-1], size = n_edges, replace=False)

      for cn2 in range(len(connected_nodes_2)):
        s_node = np.random.choice(nodes_list[source_ij-1], replace=False)

        # Make sure that the source and target nodes are not the same for ii and jj edgesets.
        while (s_node == connected_nodes_2[cn2]) and (source_ij == targets):
               s_node = np.random.choice(nodes_list[source_ij-1], replace=False)

        edge_ij =(s_node, connected_nodes_2[cn2], source_ij, targets)
        edge_sets_ij.append(edge_ij)

    df_list_2 =[]
    edge_set_ij = pd.DataFrame()

    for Eij in range(len(edge_sets_ij)):

        df2  = pd.DataFrame(np.reshape(edge_sets_ij[Eij],(1,4)), columns=['source', 'target', 'source_nodeset', 'target_nodeset'])
        df_list.append(df2)
        edge_set_ij = pd.concat([edge_set_ij, df2], axis=0, ignore_index=True)

    total_edge_set  = pd.concat([edge_set, edge_set_ij], axis = 0, ignore_index=True)

    # Applying bi-directionality.
    if bidirectional == False:
      return df_list, total_edge_set
    else:
        bi_list = []
        for df in df_list:
            bi = df.copy()
            # Swap the first and second columns
            bi[bi.columns[0]], bi[bi.columns[1]] = bi[bi.columns[1]], bi[bi.columns[0]]
            # Swap the third and fourth columns
            bi[bi.columns[2]], bi[bi.columns[3]] = bi[bi.columns[3]], bi[bi.columns[2]]
            bi_list.append(bi)

    # Cleaning up data and concatinating them in 2 variables.
        bidirectional_edge_set = pd.DataFrame()
        for i in range(len(df_list)):
            bidirectional_edge_set = pd.concat([bidirectional_edge_set, df_list[i], bi_list[i]], axis=0, ignore_index=True)

    # Removing Duplicates.

        bidirectional_edge_set.drop_duplicates(inplace=True)
        return df_list, bidirectional_edge_set


df_list

