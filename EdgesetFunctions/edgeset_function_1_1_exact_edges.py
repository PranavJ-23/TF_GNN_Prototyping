# -*- coding: utf-8 -*-
"""Edgeset_function_1_1_exact_edges

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Gtg8pZZa9UoEFfEDkLBHCwz77AxSDiqI
"""

import numpy as np
import pandas as pd
"""
Example Input:

n_nodes_list  = [10, 10, 10]
n_conn_list   = [[1,1],[2,2],[3,3],[1,3],[2,3]]
n_edges_ij    = [7,7,7,5,6]
bidirectional = False

df_list, total_edge_set = generate_graph_exact_edges(n_nodes_list, n_conn_list, n_edges_ij, bidirectional)

Different from the previous function as now the exact number of nodes between each edgeset can be specified.
This is done my entering the number of edges for the corresponding nodeset connections in "n_edges_ij". Follows the same order as before,
n_edges_ij[0] is the number of edges for connection n_conn_list[0].
"""

def generate_graph_exact_edges(n_nodes_list, n_conn_list, n_edges_ij, bidirectional):

    nodes_list   = [np.arange(n_nodes) for n_nodes in n_nodes_list]
    node_sets    = len(n_nodes_list)

    df_list = []
    edge_set = pd.DataFrame()

    edge_sets_ij = []

    for ij in range(len(n_conn_list)):
      source_ij = n_conn_list[ij][0]
      targets   = n_conn_list[ij][1]
      connected_nodes_2 = np.random.choice(nodes_list[targets-1], size = n_edges_ij[ij], replace=False)

      for cn2 in range(len(connected_nodes_2)):
        s_node = np.random.choice(nodes_list[source_ij-1], replace=False)

        # Make sure that the source and target nodes are not the same for ii and jj edgesets.
        while (s_node == connected_nodes_2[cn2]) and (source_ij == targets):
               s_node = np.random.choice(nodes_list[source_ij-1], replace=False)

        edge_ij =(s_node, connected_nodes_2[cn2], source_ij, targets)
        edge_sets_ij.append(edge_ij)

    df_list_2 =[]
    edge_set_ij = pd.DataFrame()

    for Eij in range(len(edge_sets_ij)):

        df2  = pd.DataFrame(np.reshape(edge_sets_ij[Eij],(1,4)), columns=['source', 'target', 'source_nodeset', 'target_nodeset'])
        df_list.append(df2)
        edge_set_ij = pd.concat([edge_set_ij, df2], axis=0, ignore_index=True)

    total_edge_set  = pd.concat([edge_set, edge_set_ij], axis = 0, ignore_index=True)

    # Applying bi-directionality.
    if bidirectional == False:
      return df_list, total_edge_set
    else:
        bi_list = []
        for df in df_list:
            bi = df.copy()
            # Swap the first and second columns
            bi[bi.columns[0]], bi[bi.columns[1]] = bi[bi.columns[1]], bi[bi.columns[0]]
            # Swap the third and fourth columns
            bi[bi.columns[2]], bi[bi.columns[3]] = bi[bi.columns[3]], bi[bi.columns[2]]
            bi_list.append(bi)

    # Cleaning up data and concatinating them in 2 variables.
        bidirectional_edge_set = pd.DataFrame()
        for i in range(len(df_list)):
            bidirectional_edge_set = pd.concat([bidirectional_edge_set, df_list[i], bi_list[i]], axis=0, ignore_index=True)

    # Removing Duplicates.

        bidirectional_edge_set.drop_duplicates(inplace=True)
        return df_list, bidirectional_edge_set
