# -*- coding: utf-8 -*-
"""Edgeset_function_1_0

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19g_nmy3LwPNUiKM_g0V2kvTZc-53jMFT
"""

import pandas as pd
import numpy as np
import random

"""
Function uses 5 inputs given below:

n_nodes_list : List with integers. Each value determines the number of nodes that nodeset will have.
               Dependant on position, n_nodes_list[0] will be nodeset 1.
n_edges_list : List with tuples as each element. Each tuple should contain 2 integers, the maximum and minimum number of edges per node.
               Also dependant on position as the first tuple contains the range for first nodeset. The min value cannot exceed the max value.
n_conn_list  : List, with another list as each of its elements. Used to form edges between 2 nodes sets. Use nodeset indices as integer inputs. The first value will
               indicate the source nodeset while second value denotes the target nodeset.
n_edges_ij   : List with integer inputs. Used to specify the the number of edges between different nodesets. Dependant on position as the first element in this
               will correspond to the number of edges between the first specified nodeset connection in n_conn_list.
biderictional: True or False. Use "True" if bi-directionality is required.

Example input:

n_nodes_list  = [10, 4, 6]
n_edges_list  = [(1, 2), (2, 4),(1,3)]
n_conn_list   = [[1,2],[1,3]]
n_edges_ij    = [2,2]
biderictional = False

n_nodes_list  = [10, 4,]
n_edges_list  = [(1, 2), (2, 4)]
n_conn_list   = [[1,2]]
n_edges_ij    = [4]
bidirectional = False

df_list, edge_df = generate_graph_multi_sets(n_nodes_list, n_edges_list, n_conn_list, n_edges_ij, bidirectional)

edge_df['set'] = edge_df['Source_nodeset']*10 + edge_df['Target_nodeset']
edge_df = edge_df.rename(columns={'Source_nodeset': 'source_nodeset'})
edge_df = edge_df.rename(columns={'Target_nodeset': 'target_nodeset'})
edge_df = edge_df.rename(columns={'Source': 'source'})
edge_df = edge_df.rename(columns={'Target': 'target'})

node_dict = {'ids': list(range(n_nodes_list[0]))+list(range(n_nodes_list[1])),
             'set': np.ones(n_nodes_list[0],int).tolist() + list(2*np.ones(n_nodes_list[1],int))}

node_df = pd.DataFrame(node_dict)

plotGraph(node_df, edge_df)

Outputs: Function provides 3 outputs listed below.

df_list               : List of all the dataframes of edgesets.
total_edge_set        : One dataframe with all edges. (bidirectional = False)
bidirectional_edge_set: One dataframe with all edges. (bidirectional = True)

"""

def generate_graph_multi_sets(n_nodes_list, n_edges_list, n_conn_list, n_edges_ij, bidirectional):

    nodes_list   = [np.arange(n_nodes) for n_nodes in n_nodes_list]
    edge_sets    = [[] for _ in range(len(n_nodes_list))]
    node_sets    = len(n_nodes_list)

    # Create the edgesets for ii and jj nodesets.
    for i in range(len(nodes_list)):

        for node in nodes_list[i]:
            n_edges = random.randint(n_edges_list[i][0], n_edges_list[i][1])
            connected_nodes = np.random.choice(nodes_list[i], size=n_edges, replace=False)

            for connected_node in connected_nodes:
                # Ensure that the node and connected node have different values
                while node == connected_node:
                    connected_node = np.random.choice(nodes_list[i])

                source_nodeset = i + 1
                target_nodeset = i + 1

                edge = (node, connected_node, source_nodeset, target_nodeset)
                edge_sets[i].append(edge)

    # List of ii and jj edgesets.
    df_list = []
    edge_set = pd.DataFrame()

    for i in range(len(edge_sets)):
        df  = pd.DataFrame(edge_sets[i], columns=['source', 'target', 'source_nodeset', 'target_nodeset'])
        df_list.append(df)
        edge_set = pd.concat([edge_set, df], axis=0, ignore_index=True)


    # Creating edgesets for ij nodesets.
    edge_sets_ij = []

    for ij in range(len(n_conn_list)):
      source_ij = n_conn_list[ij][0]
      targets   = n_conn_list[ij][1]
       #connected_nodes_2 = np.random.choice(nodes_list[targets-1], size = n_edges_ij[ij], replace=False)
      connected_nodes_2 = np.random.choice(nodes_list[targets-1], size = random.randint(n_edges_ij[0],n_edges_ij[1]), replace=False)

      for connected_node_2 in connected_nodes_2:
        s_node = np.random.choice(nodes_list[source_ij-1], replace=False)
        edge_ij =(s_node, connected_node_2, source_ij, targets)
        edge_sets_ij.append(edge_ij)

    df_list_2 =[]
    edge_set_ij = pd.DataFrame()

    for Eij in range(len(edge_sets_ij)):

        df2  = pd.DataFrame(np.reshape(edge_sets_ij[Eij],(1,4)), columns=['source', 'target', 'source_nodeset', 'target_nodeset'])
        df_list.append(df2)
        edge_set_ij = pd.concat([edge_set_ij, df2], axis=0, ignore_index=True)

    total_edge_set  = pd.concat([edge_set, edge_set_ij], axis = 0, ignore_index=True)

    total_edge_set['set'] = total_edge_set['source_nodeset']*10 + total_edge_set['target_nodeset']
    # Applying bi-directionality.
    if bidirectional == False:
        return df_list, total_edge_set

    else:
        bi_list = []
        for df in df_list:
            bi = df.copy()
            # Swap the first and second columns
            bi[bi.columns[0]], bi[bi.columns[1]] = bi[bi.columns[1]], bi[bi.columns[0]]
            # Swap the third and fourth columns
            bi[bi.columns[2]], bi[bi.columns[3]] = bi[bi.columns[3]], bi[bi.columns[2]]
            bi_list.append(bi)

    # Cleaning up data and concatinating them in 2 variables.
        bidirectional_edge_set = pd.DataFrame()
        for i in range(len(df_list)):
            bidirectional_edge_set = pd.concat([bidirectional_edge_set, df_list[i], bi_list[i]], axis=0, ignore_index=True)

    # Removing Duplicates.
        bidirectional_edge_set = pd.DataFrame(bidirectional_edge_set.drop_duplicates(ignore_index=True), columns = ['source','target','source_nodeset','target_nodeset'])
        bidirectional_edge_set['set'] = bidirectional_edge_set['source_nodeset']*10 + bidirectional_edge_set['target_nodeset']

        return df_list,  bidirectional_edge_set
