# -*- coding: utf-8 -*-
"""label_function_1_0

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OD3_l7MSSvNWTSUQ88E8EHFHvCxKjVTS
"""

'''
Function uses output from the multiple edge_set function as one of the inputs and n_nodes_list as the other input.
This is the same input given to the multiple edge_set function function.
Designed to work with the plotGraph function, no need to change any names.

label_function(n_nodes_list, df_list)
n_nodes_list = [10, 13, 7]
df_list      = list of edge dataframes, the first output of generate_graph.
'''

import numpy as np
import pandas as pd

def create_connections(n_nodes_list,df_list):
  nodes_list   = [np.arange(n_nodes) for n_nodes in n_nodes_list]

  # Put all nodes in one dataframe.
  nodes_df = pd.DataFrame()
  for n in range(len(n_nodes_list)):
    df_1     = pd.DataFrame(np.reshape(nodes_list[n],((n_nodes_list[n]),1)), columns = ['ids'])
    nodes_df = pd.concat([nodes_df,df_1],axis = 0, ignore_index= True)

  # Add nodeset index.
  idx_df = pd.DataFrame()
  for idx, num in enumerate(n_nodes_list, start=1):
      idx_df1 = pd.DataFrame({'set': [idx] * (num)})
      idx_df  = pd.concat([idx_df,idx_df1], axis = 0, ignore_index =True)

  nodes_df = pd.concat([nodes_df, idx_df],axis = 1)

  # Assign node features.
  node_feature = 1 + 1.1*np.random.uniform(-2, 2, size=[len(nodes_df),1])
  nodes_df     = pd.concat([nodes_df,(pd.DataFrame(node_feature, columns = ['node_feature']))],axis = 1)

  # Find adjacent nodes
  edge_df = pd.DataFrame()
  for i in range(len(df_list)):
    edge_df = pd.concat([edge_df,df_list[i]], axis = 0, ignore_index = True)

  condition_list = []
  for condition in range(len(nodes_df)):
    c1 = (edge_df['source'] == nodes_df['ids'][condition])
    c2 = (edge_df['source_nodeset'] == nodes_df['set'][condition])

    source_condition = np.logical_and(c1,c2)

    c3 = (edge_df['target'] == nodes_df['ids'][condition])
    c4 = (edge_df['target_nodeset'] == nodes_df['set'][condition])

    target_condition = np.logical_and(c3,c4)

    overall_con   = np.logical_or(source_condition, target_condition)

    df_store = edge_df[overall_con]

    condition_list.append(df_store)

  connections_list = []
  for con in range(len(condition_list)):
    rslt_df_1 = condition_list[con][condition_list[con]['source'] == nodes_df['ids'].iloc[con]][['target','target_nodeset']]
    rslt_df_1 = rslt_df_1.rename(columns = {'target':'ids','target_nodeset':'set'})

    rslt_df_2 = condition_list[con][condition_list[con]['target'] == nodes_df['ids'].iloc[con]][['source','source_nodeset']]
    rslt_df_2 = rslt_df_2.rename(columns = {'source':'ids','source_nodeset':'set'})

    connections_list.append(pd.concat([rslt_df_1,rslt_df_2], axis = 0, ignore_index = True))
  return connections_list, nodes_df


def create_lab(connections_list,nodes_df):
  label_list = []

  operation = np.sum

  for j in range(len(connections_list)):
    x1 = connections_list[j]
    sub_label_list = []
    for lab in range(len(x1)):
      c12 = x1['ids'][lab] == nodes_df['ids']
      c22 = x1['set'][lab] == nodes_df['set']
      C12 = np.logical_and(c12, c22)
      sub_label_list.append(float(nodes_df[C12][['node_feature']].iloc[0]))

    label_list.append(operation(sub_label_list))

  nodes_df = pd.concat([nodes_df, pd.DataFrame(np.reshape(label_list, (len(label_list), 1)), columns=['label'])], axis =1 )
  return nodes_df



def label_function(n_nodes_list, df_list):
  connections_list, nodes_df = create_connections(n_nodes_list, df_list)
  node_df = create_lab(connections_list, nodes_df)
  return node_df
